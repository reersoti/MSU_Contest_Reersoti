#ifndef _OS_MEM_H
#define _OS_MEM_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <memory.h>

struct mem_handle_t {
    // адрес размещения блока относительно начала всей памяти (в байтах)
    int addr;
    // размер блока в байтах
    int size;  

    mem_handle_t(int addr, int size) :
        addr(addr),
        size(size)
    {}

    bool operator==(const mem_handle_t& other) { return other.addr == addr && other.size == size; }
    bool operator!=(const mem_handle_t& other) { return !operator==(other); }
}; // дескриптор блока памяти

// Структура менеджера памяти
// угловые скобочки в комментариях к функциях означают, что берется значение соответствующей переменной, так, выдача на экран load <page_num> означает,
// что нужно выдать слово load и номер страницы page_num, например load 5 (без угловых скобочек).
typedef struct
{
    // создание менеджера памяти,
    // size: для менеджеров памяти - размер всей памяти в байтах
    // num_pages: для страничных менеджеров - количество физических страниц
    // возвращаемое значение: 1 - успех, 0 - неудача
    int (*create)(int size, int num_pages);
    
    // удаление менеджера памяти
    // возвращаемое значение: 1 - успех, 0 - неудача (например, менеждер не был создан)
    int (*destroy)();
   
    // выделение блока памяти размером block_size байт
    // для менеджеров памяти с фиксированным размером блока памяти аргумент функции игнорируется.
    // возвращаемое значение: дескриптор выделенного блока - успех, нулевой дескриптор {0,0} - неудача
    mem_handle_t (*alloc)(int block_size);
    
    // освобождение блока памяти с дескриптором h
    // возвращаемое значение: 1 - успех, 0 - неудача (например, неверный дескриптор)
    int (*free)(mem_handle_t h);
    
    // возвращает дескриптор выделенного блока памяти, целиком содержащего указанный регион
    // в случае, если такого блока не существует, возвращается нулевой дескриптор {0,0}
    mem_handle_t (*get_block)(int addr, int size);
    
    // возвращаемое значение: максимальный размер блока памяти (в байтах), который может быть сейчас выделен
    int (*get_max_block_size)();
    
    // возвращаемое значение: суммарный объем свободной памяти в байтах
    int (*get_free_space)();
    
    // распечатывает все выделенные блоки памяти в формате <аddr> <size>
    // порядок блоков - по возрастанию адресов.
    void (*print_blocks)();

} memory_manager_t;

void setup_memory_manager(memory_manager_t* mm);

#endif
